---
title: 装饰器
summary: 详细介绍python的装饰器的原理和用法
date: 2019-10-19
author: LY
categories:
    - python
tags:
    - python语法
---

## 装饰器的概念

装饰器从理论上讲，就是它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能

这里拿个案例来讲：

开发公司原本是每个部门都调用同样的一个底层函数，后来要在使用函数前加上一个权限验证代码

很多人一开始可能都是这样想的

```python
def check():
    print('--检查权限--')
def f1():
    check()
    pass
def f2():
    check()
    pass
def f3():
    check()
    pass
def f4():
    check()
    pass
```

但这种代码违背了**开放封闭原则**，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，**它规定已经实现的功能代码不允许被修改**，但可以被扩展，这个也就是**单例模式**，在不改变别人使用的情况下，在内部写好增加的功能，即：

- 封闭：已实现的功能代码块
- 开放：对扩展开发

如果将开放封闭原则应用在上述需求中，那么就不允许在函数 f1 、f2、f3、f4的内部进行修改代码



根据之前学过的闭包，可以把函数的引用封装进check()函数里面，然后再次调用闭包函数就可以实现每个函数使用前都加上inner函数，代码如下

```python
def check(func):
    def inner():
         print('--检查权限--')
    return inner
def f1():
    pass
f1=check(f1) #将f1函数传入check函数里面，然后再去调用
f1()
```

但是这个代码有很大的问题，也违反了开放封闭原则，就是每个部门都要加上这一行代码`f1=check(f1)`

所以下面介绍python的特殊写法，也叫做语法糖

```python
def check(func):
    def inner():
         print('--检查权限--')
    return inner
@check
def f1():
    pass
f1() 
```

@check就代替了f1=check(f1)这行代码，这样每个部门都可以像原来的写法那样调用而且又可以加入检察权限函数了



## 两个装饰器

假如有两个装饰器，他

```python
def makebold(fn):
    print('--test1--')
    def wrapped():
        print('--1--')
        return '<b>'+fn()+'</b>'
    return wrapped
def makeitalic(fn1):
    print('--test2--')
    def wrapped():
        print('--2--')
        return '<i>'+fn1()+'</i>'
    return wrapped

@makebold
@makeitalic
def test():
    print('test')
    return 'hello world 3'

res=test()
print(res)
```

```
--test2--
--test1--
--1--
--2--
test
<b><i>hello world 3</i></b>
```

**两个装饰器的运行顺序是这样的：python解释器从上往下执行，执行到@makebold，然后返回值还是一个装饰器，然后接着@makeitalic执行,然后makeitalic返回才是一个函数，所以这个顺序是倒着执行的，是test()-->makeitalic()-->makebold()**，调用的时候是从上往下调用，装饰器执行是从下往上执行

## 装饰器的执行时间

```python
def check(func):
    print('--执行--')
    def inner():
         print('--检查权限--')
    return inner
@check
def f1():
    pass
#输出 --执行--
```

从上述代码看出，在执行到@check这一行的时候，就已经执行check函数里面的内容了，而不是要等到f1()的时候再去调用

## 装饰器对有参数函数进行装饰

假如在调用函数的时候需要加入参数，就必须在定义的闭包函数里面也要加入对应的形参，不然会无法调用

```python
def check(func):
    print('--执行--')
    def inner(*args,**kwargs):
         func(*args)
    return inner
@check
def f1(a,b,c):
    print('a是%d,b是%d,c是%d'%(a,b,c))

f1(11,22,33)
```

## 带返回值的装饰器

```python
def func(function):
    def inner():
        ret=function()
        return ret
    return inner
@func
def test():
    print('--test--')
    return '23333'
ret=test()
print('返回值是%s'%ret)
```

```
--test--
返回值是23333
```

定义返回值也要在闭包函数里面添加相对应的返回值

## 有参数的装饰器

在开发中会出现一个外部变量，如@装饰器名字('变量')的形式，此时就需要多一个闭包函数

```python
def func_args(arg):
    def func(function):
        def inner():
            if arg=='2333':
                function()
            else:
                pass
        return inner
    return func

@func_args('2333')
def test():
    print('--test--')
test()
#结果 --test--
```

这样就可以想对什么进行装饰就对什么进行装饰了

## 用类当做装饰器进行装饰

在讲这个之前要懂一个方法

```python
class Test(object):
    pass
t=Test()
t()
```

这样直接调用的话会导致`TypeError: 'Test' object is not callable`错误，所以要在类中声明`__call__`方法

```python
class Test(object):
    def __call__(self, *args, **kwargs):
        print('--test--')
    pass
t=Test()
t()
#--test--
```

这样子就可以运行了

使用类装饰器的形式是这样子的

```python
class Test(object):
    def __init__(self,func):
        print('初始化')
        print('函数的名字为%s'%func.__name__)
        self.__func=func
    def __call__(self, *args, **kwargs):
        print('--装饰器的功能--')
        self.__func

@Test
def test():
    print('--test--')
test()
```

