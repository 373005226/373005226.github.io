---
title: 天天生鲜项目总结（二）
summary: 总结了天天生鲜项目的常用功能
date: 2019-10-14
author: LY
categories:
    - 项目总结
tags:
    - Django
---

## 使用Redis作为Django的缓存来存储用户登录状态

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常网站用的都是session和cookie作为记录用户信息的存储，Django默认是把session存储在数据库中，每一次用户使用网站，都要从数据库从读取session，但是直接读取数据库的速度是比较慢的。其次，网站如果每次用户访问都是从数据库进行读取，那么对服务器的压力也是不小的。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在小网站可以这样子做，如果大型网站人流量一大，每一个人访问网站都会对数据库进行一次读取，对服务器是个不小的压力，而如果使用Redis作为缓存存储数据就不会出现这类问题。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django使用Redis作为缓存的使用手册如下：[https://django-redis-chs.readthedocs.io/zh_CN/latest/](https://django-redis-chs.readthedocs.io/zh_CN/latest/)，这里只简述使用方法:

安装Django-redis

```python
pip install django-redis
```

然后在setting文件里面添加配置项

```python
#Django的缓存配置
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/9",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}
```

&emsp;

其次Django默认的存储方式有如下三种：

1. 存储在数据库中，如下设置可以写，也可以不写，这是默认存储方式

   ```python
   SESSION_ENGINE='django.contrib.sessions.backends.db'
   ```

   Django默认的存储方式就是在数据中存储，所以在`setting`字段里面有个

   ```python
   INSTALLED_APPS = [
   ........
       'django.contrib.sessions',
   ........
   ]
   ```

   在使用命令`migrate`和`makemigrations`后在数据库就会生成一个django_session字段，如图所示：

   ![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571198881213.png)

2. 存储在缓存中：存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快

   ```python
   SESSION_ENGINE='django.contrib.sessions.backends.cache'
   ```

3. 混合存储：优先从本机内存中存取，如果没有则从数据库中存取。

    ```python
    SESSION_ENGINE='django.contrib.sessions.backends.cached_db'
    ```

&emsp;

项目需要的是把redis缓存替换默认方法，依照官方文档的方法：

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571199075048.png)

在setting里面添加如下两个字段：

```python
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "default"
```

这样就可以完成使用Redis来存储session了

&emsp;

## 个人中心页面登陆限制

按照逻辑来说，个人中心的信息在没登录的时候即使输入了URL地址也是直接跳转到登陆信息的，当登陆完成之后再返回登陆之前访问的页面。本项目就按照这个逻辑去写。

Django有一套验证系统，可以记录用户访问前的地址和可以让登陆后再返回之前访问的地址

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571214022489.png)



上述验证方法有两个方法可以实现：

### 方法一：在路由里面添加

在每个单独的包的路由里面设置一个`login_required`，如图所示：

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571214344034.png)

配置完之后，紧接着要在setting里面添加你的登陆地址，当访问个人中心页面自动跳转到登陆页面

```python
LOGIN_URL = '/login'
```

重启项目，输入地址栏访问个人中心查看

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571215011716.png)

最重要的一步来了，就是表单继续提交的时候会发现情况不对，返回的还是首页页面，这个原因是因为form表单action提交的还是原来的地址，这里注意要删掉action字段，因为form表单如果不加上action就是提交到url地址的那栏，也就是`127.0.0.1:8000/user/login?next=/user/`，这个时候我们就要去修改登陆的方法类，也就是post请求要修改一下

这是我原来的代码：

```python
login(request,user)
.......
#在登陆成功之后跳转到首页
return redirect(reverse('goods:index'))
```

`127.0.0.1:8000/user/login?next=/user/`这个地址一看就是get方法请求的，我们直接在Request里面获取即可

```python
login(request,user)
next_url=request.GET.get('next',reverse('goods:index'))#如果拿不到next，就默认赋值为goods:index，也就是默认跳转到首页
response=redirect(next_url)
........
return response
#这里我修改了下我的写法，原理是一样的，都是跳转到要响应的页面
```

经过上述配置，就可以完成开头所说的逻辑了

&emsp;

### 方法二：使用LoginRequiredMixin类

在方法一里面，虽然是可以完成逻辑上的方法，但是这样未免很麻烦，每需要一个要限制登陆的页面，都要在路由里面添加限制，一两个无所谓，但是如果很多歌页面都需要限制登陆那未免就显得十分的麻烦。对于这种情况，我们应该封装在一个类里面做而不是在路由里面写。详细实现方法如下：

&emsp;

![官方文档](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571216461437.png)

官方文档写的也是十分的详细，虽然是全英文~~~整体而言方法是定义一个类，在类里面进行判断即可

对于这种对于全局都有作用的函数我封装到一个`utils`的文件夹里，并且取名为`Mixin.py`

我们自定义一个类，类名我取名为`LoginRequiredMixin`

先点击ctrl+as_view()查看类的实现方法

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571216810096.png)

这个方法我看了看，使用的是类方法来执行的

不管他，我直接copy过来

```python
from django.contrib.auth.decorators import login_required


class LoginRequiredMixin(object):
    @classmethod
    def as_view(cls, **initkwargs):
```

然后继承父类的方法，完整的代码如下

```python
from django.contrib.auth.decorators import login_required


class LoginRequiredMixin(object):
    @classmethod
    def as_view(cls, **initkwargs):
        view = super(LoginRequiredMixin, cls).as_view(**initkwargs)
        return login_required(view)
    
#这样我就可以定义一个是否需要被限制登陆的类了
```



然后在定义个人中心、订单、地址的类方法中继承这个方法即可，详情如下：

```python
class UserInfoView(LoginRequiredMixin,View):
.......
class UserOrderView(LoginRequiredMixin,View):
.......
class UserAddressView(LoginRequiredMixin,View):
```

这样就可以实现更为简便的方法了

这个方法的原理还是跟方法一一模一样的，`return login_required(view)`还是在view外面包装了一个`login_required`，只是这样写会没那么乱

&emsp;

## 添加用户历史浏览记录

添加用户历史浏览记录我这里使用的是`hash`数据结构存储。依照逻辑来说，能记录用户浏览记录肯定是要先登录的，所以要先对用户判断是否登陆，具体代码如下：

```python
if user.is_authenticated:
# 用户已经登录
conn = get_redis_connection('default')
cart_key = 'cart_%d' % user.id

# 获取用户购物车中的商品条目数
cart_count = conn.hlen(cart_key)  # hlen hash中的数目

context.update(cart_count=cart_count)
```

## 显示历史浏览记录

每次访问商品详情页的时候，都会使用Redis的list数据结构去保存用户浏览信息，在获取浏览记录的时候 使用`lrange key start stop`就可以自定义取多少条数据，假如要取A1的所有数据：`lrange A1 0 -1`

根据Django-redis的官方文档显示：

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571232502432.png)

这里面的`default`就是之前配置的字段，如图所示

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571232579990.png)

在连接redis数据库之后，在数据字段里面显示前五个商品信息

```python
con=get_redis_connection('default')
history_key='history_%d'%user.id
sku_ids=con.lrange(history_key,0,4)

goods_li=GoodSKU.objects.filter(id__in=sku_ids)
#使用两层列表的原因是因为输入[2,1,3]，在mysql得出的结果顺序依然为1，2，3，所以只能用两层循环去遍历
goods_res=[]
for a_id in sku_ids:
    for goods in goods_li:
        if a_id==goods.id:
            goods_res.append(goods)
```

## 后台自定义使用FastDFS存储资源

Django默认保存资源是保存在Media_root指定目录下方，现在我这个项目要改成FastDFS服务器上，所以这里要修改文件的默认存储路径，这里还是直接查看Django文档

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571232579990.png)

也就是说Django保存文件使用的是`FileSystemStorage`这个类，其中save方法实现了保存

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571233304579.png)

但是我们不能直接去修改源码，所以Django内置好了一套给我们自己去定义的存储类，我们只需要去继承`FileSystemStorage`的父类`Storage`就可以，继承`Storage`还必须要实现save和open方法，这里保存图片只需要实现save方法即可

同样我自定义存储类的方法卸载一个单独的文件夹下，这里我定义在utils里面的FastDFS文件夹下

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571235260232.png)

里面的蓝色的`storage`就是自定义的文件，`client.conf`是我FasDFS的配置文件，基本上的功能，上传图片资源的模块我都已经写好了，直接修改自己的服务器IP就可以经行第二次开发

## 页面资源静态化

在网站中，无论用户是否登陆都显示同一个页面，而如果人流量访问的越多，每个人访问都从数据库调用一遍就是一个非常伤服务器的操作，所以要把网站的常用页面给静态化。这里用的还是Celery去异步操作，具体的操作代码上的注释写的很详细，我这里只讲解我对这个问题的解决方案。

&emsp;

Django默认的后台`admin`是有一个`save_model`方法，也就是新增或更新数据时会自动调用，而我这个项目使用的是`xadmin`，不能直接调用`admin`的方法，依照网上博客的方法也不行，又不能去改写源代码，所以我想了个办法：在每次`return`返回给`index.html`数据的前，我都会先写一个缓存，这个缓存保存了返回给前端的数据，如果第二次访问的时候发现缓存改变了就给异步发送请求重新加载静态页面，如果没有改变就只进行一次对比之后返回静态页面，关键代码如下：

```python
 context = {
            'types': types,
            'index_banner': index_banner,
            'promotion_banner': promotion_banner,
        }

        if context is None:
            # 设置缓存数据,缓存的名字，内容，过期的时间
            cache.set('index_page_data', context, 3600)

        if context!=cache.get('index_html_data'):
            generate_static_index_html.delay()
```

## 分页

分页这个其实官方文档说的比较清楚了

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571237664233.png)

初次之外还有一个方法，在github上start也有几百了，地址如下：[https://github.com/jamespacileo/django-pure-pagination](https://github.com/jamespacileo/django-pure-pagination)

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571237740809.png)

这个功能也是比较完善的，还具备前一页后一页的功能，最重要的是还带有省略号的功能，而且使用起来也挺简单的，不过这里因为我的图片资源本来就少，用不着折腾这个所以就没用

## 商品搜索

在商品搜索功能上，Django有一个全文检索框架`haystack`，开发者可以通过全文检索框架去使用搜索引擎,`haystack`支持whoosh、solr、Xapian、Elasticsearch四种全文检索引擎

### 配置项

首先先安装`haystack`

```python
pip install django-haystack
#你要用哪个搜索引擎就下载哪个，我这里用的是whoosh
pip install whoosh
```

然后在setting的INSTALLED_APPS添加`haystack`，紧接着要在setting里面添加如下字段：

```python
# 全文检索框架配置
HAYSTACK_CONNECTIONS = {
    'default': {
        # 使用whoosh引擎
        'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine',
        # 索引文件路径
        'PATH': os.path.join(os.path.dirname(__file__), 'whoosh_index'),
    },
}

# 当添加、修改、删除数据时，自动生成索引
HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'
```

### 配置索引文件

在你需要被检索的包里面新建一个`search_indexes.py`文件，里面需要你配置的只有三个地方，代码如下：

```python
import datetime
from haystack import indexes
#第一个地方，导入你的模型类
from goods.models import GoodsSKU

#第二个地方：索引类的格式名：模型类+Index
class GoodsSKUIndex(indexes.SearchIndex, indexes.Indexable):
    #索引字段document=True指定根据表的哪些字段简历索引文件制定在一个文件中
    text = indexes.CharField(document=True, use_template=True)
    # author = indexes.CharField(model_attr='user')
    # pub_date = indexes.DateTimeField(model_attr='pub_date')
    
#第三个地方：返回你的模型类
    def get_model(self):
        return GoodsSKU

    # 建立索引数据
    def index_queryset(self, using=None):
        return self.get_model().objects.all()
        #返回所有数据就是对所有的数据进行索引
```

配置完上面的字段后，需要自定义需要被检索的字段，格式为`模型类名的小写_text.txt`，比如我的是`GoodsSKU`，格式就为`goodssku_text.txt`,这个文件建立的地方是有要求的，比如我这里的形式如下：

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571240232653.png)

search和indexes是固定的，goods是你的应用名字就是什么名字。`goodssku_text.txt`里面填写你要索引的字段，我的如下

```python
# 指定根据表中的哪些字段建立索引数据
{{ object.name }}  # 根据商品的名称建立索引
{{ object.desc }}  # 根据商品的简介建立索引
{{ object.goods.detail }}  # 根据商品的详情建立索引
```

然后使用python shell命令`python manage.py rebuild_index`就可以生成你的索引文件

### 搜索的页面

搜索地址框搜索出来的页面也是单独设定的，首先搜索框的action的地址应该改为`<form method='get' action='/search'>`

这里的action写什么，url地址那里就写什么，我的是search，所以url地址就是search

然后在全局的url地址那里添加`url('search/', include('haystack.urls')),  # 全文检索框架`

最后要写一个搜索后出现的页面，搜索的页面要在indexes文件夹下，新建的搜索页面名字为`search.html`,里面关键展示部分的数据如下：

```python
搜索的关键字： {{ query }} <br/>
当前页的Page对象： {{ page }}  <br/>
<ul>
    {% for item in page %}
        <li>{{ item.object }}</li>
    {% endfor %}
</ul>
分页Paginator对象: {{ paginator }} <br/>
```

自己去定义一个搜索后的页面，显示部分改成如上关键词就可以了

### 使用jieba进行分词处理

我们汉语向来都是博大精深，不像英语一个单词就是一个意思，所以我们可以使用jieba包去对搜索的文字进行分词处理

首先先安装jieba分词

```python
pip install jieba
```

然后去找haystack的源码目录

![](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1571242333996.png)

创建一个`ChineseAnalyzer.py`文件，输入以下代码：

```python
import jieba
from whoosh.analysis import Tokenizer, Token

class ChineseTokenizer(Tokenizer):
    def __call__(self, value, positions=False, chars=False,
                 keeporiginal=False, removestops=True,
                 start_pos=0, start_char=0, mode='', **kwargs):
        t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs)
        seglist = jieba.cut(value, cut_all=True)
        for w in seglist:
            t.original = t.text = w
            t.boost = 1.0
            if positions:
                t.pos = start_pos + value.find(w)
            if chars:
                t.startchar = start_char + value.find(w)
                t.endchar = start_char + value.find(w) + len(w)
            yield t

def ChineseAnalyzer():
    return ChineseTokenizer()
```

这个代码其实就是对搜索框输入的字符串进行jieba分词处理

然后复制`whoosh_backend.py`文件为`whoose_cn_backend.py`，因为最好不要去修改源码

在新的文件`whoose_cn_backend.py`修改一些字段：

```
#第一处要导入刚刚的jieba分词的包
from .ChineseAnalyzer import ChineseAnalyzer

第164行改成 TEXT(stored=True, analyzer=ChineseAnalyzer()
```

最后修改setting的`'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine'`改为`'ENGINE':'haystack.backends.whoosh_cn_backend.WhooshEngine'`

最后执行python shell命令`python manage.py rebuild_index重新生成索引文件就可以jieba分词搜索了

## 订单并发

在Django的订单页面，处理订单的高并发处理有两种方法，一种叫悲观锁，另一种叫乐观锁

### 悲观锁

当查询某条记录时，即让数据库为该记录加锁，锁住记录后别人无法操作，使用类似如下语法

```python
select stock from tb_sku where id=1 for update;
SKU.objects.select_for_update().get(id=1)
```

这个跟多线程的互斥锁原理十分的相像

### 乐观锁

乐观锁不是锁，只是在修改数据库库存的时候跟修改前的数据做对比，判断修改时的库存是不是跟之前查询的库存一样，连续判断两次，如果不一样就不执行这个操作，一样就执行更改

### 其他方法

这个其实不止有如上两个方法的，比如还有延迟队列、Redis集群来设计，但是单单对于Django来说这两个方法也足够应付了