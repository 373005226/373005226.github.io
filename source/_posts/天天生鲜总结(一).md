---
title: 天天生鲜项目总结（一）
summary: 总结了天天生鲜项目的常用功能
date: 2019-10-14
author: LY
categories:
    - 项目总结
tags:
    - Django
---

> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做天天生鲜项目的时候使用了太多的技术，很多不会的我参考了很多的博客才做出来，这里记录这个项目的常用技术点，以便于我开发第二个系统
>

## 使用Django内置的方法发送邮件

首先先在setting.py文件里面配置你的邮件服务器，邮件服务器在QQ邮箱、网易163邮箱可以免费注册。

将SMTP服务器的配置信息放到setting.py文件里面，配置信息如以下格式：

```python
EMAIL_HOST = "smtp.qq.com"
EMAIL_PORT = 25
EMAIL_HOST_USER = "373005226@qq.com"
EMAIL_HOST_PASSWORD = "***************"
EMAIL_USE_TLS= False
EMAIL_FROM = "373005226@qq.com"
```

然后在需要发送邮件的方法内导入需要的包就可以使用Django内置的发送邮件函数了

```python
#导入setting刚刚配置的文件
from dailyfreshshop.settings import SECRET_KEY,EMAIL_FROM
#使用Django内置的发送方法
from django.core.mail import send_mail

email_title = "天天生鲜注册激活链接"
email_body = ''
sender = EMAIL_FROM
receiver = [email]
html_message = "<h1>%s，欢迎您注册天天生鲜商城，请点击下面的连接激活你的账号</h1>" \
"<a href='http://127.0.0.1:8000/active/%s'>http://127.0.0.1:8000/active/%s</a>" % (
    username, token, token)
send_mail(email_title, email_body, sender, receiver, html_message=html_message)
#发送函数的参数
#第一个参数email_title是标题
#第二个参数email_body是内容，但是这个内容只能是字符串，如果再html_message写了这里就可以不写
#第三个参数sender是setting配置好的SMTP服务器内容
#第四个参数receiver是要发送的人的邮箱账号
#第五个参数html_message=html_message，这个是如果你的内容共有html标签的话可以解析成html内容
```



## 邮箱注册，用户信息加密

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在发送邮件注册验证码的时候，为了防止有心人注册之后使用发送过来的激活码调整激活码中用户的ID，不停地输入修改后的激活码就会给服务器带来压力，所以在发送邮箱激活码的时候一定要加密，并且设置时间

&emsp;

使用文档：https://itsdangerous.readthedocs.io/en/1.1.x/

安装加密库：

```
pip install -U itsdangerous
```

&emsp;

打开python shell模拟使用方法：

```python
>>> from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
>>> serializer=Serializer('secretkey',3600)
>>> info="123"
>>> res=serializer.dumps(info)
>>> res
b'eyJhbGciOiJIUzUxMiIsImlhdCI6MTU3MTA0MDYyNCwiZXhwIjoxNTcxMDQ0MjI0fQ.IjEyMyI.jvwwArkwJP0sBMDyO8ydqIndyd1EqvrvsHAYah4sMqWhR4PFvaoQJ3rpybXmJMjbX4GTHNf1Fw_cCCFfuaixpQ'
>>> serializer.loads(res)
'123'
>>>

"------------------把过期时间设置成2秒-------------------------"
>>> serializer=Serializer('secretkey',2)
>>> info2="123"
>>> res=serializer.dumps(info2)
>>> res
b'eyJhbGciOiJIUzUxMiIsImlhdCI6MTU3MTA0MDc2NiwiZXhwIjoxNTcxMDQwNzY4fQ.IjEyMyI.ePHmZzoJN1bPNhfI-QOM22ZcqUXjdYLuReDSd2AMu3Sgn1zCwcWTjTSTZq5ZD97WnzVou8J65qgb2fRh_Elpgg'
>>> 两秒后
>>> serializer.loads(res)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "C:\Users\LY\Envs\dailyfresh\lib\site-packages\itsdangerous\jws.py", line 205, in loads
    date_signed=self.get_issue_date(header),
itsdangerous.exc.SignatureExpired: Signature expired
```

以如上的测试依据，添加代码

**注册发送邮箱激活码的类：**

```python
#邮箱的激活码是由用户的ID去加密而成的
serializer = Serializer(SECRET_KEY, 180)
info = {'confirm':user.id}
token=serializer.dumps(info)
token = token.decode('utf8')
```

&emsp;

**激活验证码的类**

```python
class AciveUserView(View):
    def get(self,request,token):
        serializer = Serializer(SECRET_KEY, 180)
        try:
            info=serializer.loads(token)
            #获取info的用户id
            user_id=info['confirm']
            #根据id来获取用户信息
            user=User.objects.get(id=user_id)
            user.is_active=1
            user.save()
            return redirect(reverse('login'))
        except SignatureExpired as e:
            #激活链接过期了
            return HttpResponse('激活链接过期，请重新提交')
```

这样就可以保证每一次发送的激活码都唯一，这样就保证了激活码的安全性



## 异步方式

![Celery流程图](https://txy-tc-ly-1256104767.cos.ap-guangzhou.myqcloud.com/%E5%A4%A9%E5%A4%A9%E7%94%9F%E9%B2%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/3.png)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; broker可以选择RabbitMQ和Redis作为消息中间人去处理耗时任务，RabbitMQ是生产环境中最佳的选择，使用文档如下：[http://docs.celeryproject.org/en/latest/getting-started/brokers/rabbitmq.html#broker-rabbitmq](http://docs.celeryproject.org/en/latest/getting-started/brokers/rabbitmq.html#broker-rabbitmq)，Redis也是一款功能完备的broker选项，虽然整体而言是肯定不如RabbitMQ的，但它本身支持MQ功能，RabbitMQ有的Redis也能基本上实现，所以完全可以当做一个轻量级的队列服务来使用。关于Redis和RabbitMQ之间的比较可以看我这篇博客：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在网站设计中，邮件发送等操作还算是比较耗时的，如果发送邮件和完成跳转是同步进行的话，要等邮件发送完成再跳转到指定页面，停顿的那几秒就会给用户带来很不好的体验，所以异步耗时操作最好是交给异步方法去执行。这个项目我拿的是redis作为中间件来执行

## 异步发送邮件

第一步当然是redis服务器能够正常启动啦，我的redis服务器是部署到本地的

第二步是把需要异步操作的任务封装成函数，然后把原来同步操作的步骤使用异步的函数代替

```python
from django.core.mail import send_mail
from django.conf import settings
from celery import Celery

#--------------这一段是异步任务执行端必须加入以下代码--------------------
import os
import django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dailyfreshshop.settings')
django.setup()
#------------------------------------------------------------------

#celery_tasks是我存放异步任务的文件夹
app = Celery('celery_tasks.tasks', broker='redis://127.0.0.1/8')

#必须加上装饰器才可以变成异步任务
@app.task
def send_register_active_email(to_email, username, token):
    """发送激活邮件"""
    # 组织邮件信息
    subject = '天天生鲜欢迎信息'
    message = ''
    sender = settings.EMAIL_FROM  # 发送人
    receiver = [to_email]
    html_message = '<h1>%s, 欢迎您成为天天生鲜注册会员</h1>请点击下面链接激活您的账户<br/><a href="http://127.0.0.1:8000/user/active/%s">http://127.0.0.1:8000/user/active/%s</a>' % (username, token, token)

    send_mail(subject, message, sender, receiver, html_message=html_message)
```

&emsp;

最后需要执行命令

windows端：

```python
celery -A celery_tasks.tasks worker -l info -P eventlet
```

Linux端：

```
celery -A celery_tasks.tasks worker -l info
```

看到ready就表示异步任务已经就绪啦，等待发送异步请求。而在原来的需要同步发送邮件的地方只需要改成异步函数的代码即可

```python
from celery_tasks.tasks import send_register_active_email

........

    def post(self,request):
        username = request.POST.get('registerUsername', '')
        password1 = request.POST.get('registerPassword', '')
        password2 = request.POST.get('registerPasswords', '')
        email = request.POST.get('registeremail', '')
        if password1 == password2:
            password = password1
        else:
            return render(request, 'register.html', {'error': "两次密码不一致，请重新填写"})

        if not all([username, password, email]):  # all可以自动验证数据是否完整
            return render(request, 'register.html', {'errormsg': '数据不完整，请重新填写'})

        register_form = RegisterForm(request.POST)
        if register_form.is_valid():
            if User.objects.filter(email=email):
                return render(request, "register.html", {"register_form": register_form, "email_msg": "邮箱已注册"})
            if User.objects.filter(username=username):
                return render(request, "register.html", {"register_form": register_form, "user_msg": "用户名已存在"})

            user = User.objects.create_user(username, email, password)
            user.is_active = False
            user.save()

            #加密用户的id发送链接
            serializer = Serializer(SECRET_KEY, 180)
            info = {'confirm':user.id}
            token=serializer.dumps(info)
            token = token.decode('utf8')

            # email_title = "天天生鲜注册激活链接"
            # email_body = ''
            # sender = EMAIL_FROM
            # receiver = [email]
            # html_message = "<h1>%s，欢迎您注册天天生鲜商城，请点击下面的连接激活你的账号</h1>" \
            #                "<a href='http://127.0.0.1:8000/active/%s'>http://127.0.0.1:8000/active/%s</a>" % (
            #                    username, token, token)
            # send_mail(email_title, email_body, sender, receiver, html_message=html_message)
			
            #---------------------------------------------------------
            send_register_active_email.delay(email, username, token)

            return HttpResponse('邮箱验证码已经发送到您的邮箱，请点击连接激活')
        else:
            return render(request, 'register.html', {'msg': '表单不准确'})
```



## Django注册登录表单验证

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Django有一套自己的表单验证方法，所以在注册登录等提交表单的操作时，可以在进行数据操作前使用表单验证一遍先，然后注册登录Django都有自己内置的方法，比如验证用户名密码不用我们自己去重写登陆逻辑，只需要`authenticate`内填上账号密码的参数就可以登陆。登陆方法也不用我们去写cookie等方法，直接一个login调用即可， 这里我拿项目的案例来说明

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 新建一个froms.py文件

```python
#要添加以下两个包
from django import forms
from captcha.fields import CaptchaField

class LoginForm(forms.Form):
    """
    这里的两个字段必须跟前台input定义的name相同
    """
    username=forms.CharField(required=True)
    password=forms.CharField(required=True)


class RegisterForm(forms.Form):
    """
    这里对注册的表单进行验证和生成验证码，验证码的方法captcha已经写好了
    验证码会在前台生成一个hidden的input框，后台会生成一长串的字符串，然后联合查询验证码的正确与否
    """
    registerUsername=forms.CharField(required=True,min_length=2)
    registerPassword=forms.CharField(required=True,min_length=6)
    registeremail=forms.EmailField(required=True,min_length=6)               #使用forms.EmailField会对邮箱进行正则表达式的匹配，就不用开发者自己来写了
    captcha = CaptchaField(error_messages={"invalid":"验证码错误"})
```

类只需要继承`forms.Form`就可以定义表单验证系统了。`Form`内部自定义了表单验证的错误信息和验证系统，`EmailField`如果你的邮箱格式不对也会返回一个错误。`captcha`是验证码字段，`CaptchaField(error_messages={"invalid":""})`是可以自定义文件错误

&emsp;

在进行数据库操作的时候可以先进行数据的验证，案例如下：

```python
#注册逻辑
class RegisterView(View):

    def get(self,request):
        register_form=RegisterForm()
        return render(request,'register.html',{'register_form':register_form})
    def post(self,request):
        username = request.POST.get('registerUsername', '')
        password1 = request.POST.get('registerPassword', '')
        password2 = request.POST.get('registerPasswords', '')
        email = request.POST.get('registeremail', '')
        if password1 == password2:
            password = password1
            else:
                return render(request, 'register.html', {'error': "两次密码不一致，请重新填写"})

            if not all([username, password, email]):  # all可以自动验证数据是否完整
                return render(request, 'register.html', {'errormsg': '数据不完整，请重新填写'})

            #重点在这里，从这里定义我刚刚写的form表单验证
            register_form = RegisterForm(request.POST)
            if register_form.is_valid():
                if User.objects.filter(email=email):
                    return render(request, "register.html", {"register_form": register_form, "email_msg": "邮箱已注册"})
                if User.objects.filter(username=username):
                    return render(request, "register.html", {"register_form": register_form, "user_msg": "用户名已存在"})

                user = User.objects.create_user(username, email, password)
                user.is_active = False
                user.save()

                #加密用户的id发送链接
                serializer = Serializer(SECRET_KEY, 180)
                info = {'confirm':user.id}
                token=serializer.dumps(info)
                token = token.decode('utf8')

                send_register_active_email.delay(email, username, token)

                return HttpResponse('邮箱验证码已经发送到您的邮箱，请点击连接激活')
            else:
                return render(request, 'register.html', {'msg': '表单不准确'})
 
#登陆逻辑
class LoginView(View):
    def get(self,request):
        if 'username' in request.COOKIES:
            username=request.COOKIES.get('username')
            checked='checked'
        else:
            username=''
            checked=''
        return render(request,'login.html',{'username':username,'checked':checked})

    def post(self,request):
        username=request.POST.get('username','')
        password=request.POST.get('password','')
        if not all([username,password]):
            return render(request, 'login.html', {'errormsg': '数据不完整，请重新填写'})

        login_form=LoginForm(request.POST)
        if login_form.is_valid():
            user=authenticate(username=username,password=password)
            if user is not None:
                if user.is_active:
                    login(request,user)       #login方法是Django后台自定义的登陆方法，内置了cookie和session的方法

                    #默认登陆后跳转到首页
                    next_url=request.GET.get('next',reverse('goods:index'))

                    response=redirect(next_url)

                    #判断是否记住用户名
                    remember=request.POST.get('remember')

                    if remember == "on":
                        response.set_cookie('username',username,max_age=7*24*3600)
                    else:
                        response.delete_cookie('username')

                    return response
                else:
                    return render(request,"login.html",{"email_msg":"你的邮箱未激活"})
            else:
                return render(request,'login.html',{"user_msg":"用户名或密码错误"})
        else:
            return render(request,"login.html",{"login_form":login_form})
```

&emsp;

在写前端的时候，在定义好的表单错误样式里，写上这么一条语句

```html
<div class="form-group">
    <input id="register-password" class="input-material {% if register_form.errors.registerPassword %}error{% endif %}" type="password"
           name="registerPassword" placeholder="请输入密码">
    <div class="invalid-feedback">
        密码必须在6~10位之间
    </div>
</div>
<div class="form-group">
    <input id="register-passwords" class="input-material {% if register_form.errors.registerPassword %}error{% endif %}" type="password"
           name="registerPasswords" placeholder="确认密码">
    <div class="invalid-feedback">
        两次密码必须相同 且在6~10位之间
    </div>
</div>
<div class="form-group">
    <input id="register-email" class="input-material {% if register_form.errors.registeremail %}error{% endif %}" type="email"
           name="registeremail" placeholder="邮箱">
    <div id="login-username-error" class="is-invalid invalid-feedback"
         style="display: block;">{{ email_msg }}</div>
    <div class="invalid-feedback">
        邮箱格式不正确
    </div>
</div>
<div class="form-group captcha1 {% if register_form.errors.captcha %} error {% endif %}">
    {{ register_form.captcha }}
</div>
```

前端案例上的`register_form.errors`是刚刚forms定义好的字段，如果提交后字段错误，就会返回错误信息`registerPassword` 是`erros`遍历出来的错误信息中





